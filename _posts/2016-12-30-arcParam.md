---
layout: post
title:  "How to parametrize a circular arc"
date:   2016-12-30 11:55 +0100
categories: se math
cjs:
  version: v0.8
katex: true
---

In the Math Stack Exchange post titled
[Get a curve through three points whose samples are evenly distributed][1],
[Ben Andersen][2] asked about a way to map values
<script type="text/x-tex">\mu\in[0,1]</script>
to points in the plane based on the position of three points
<script type="text/x-tex">P_0,P_1,P_2</script>
such that for <script type="text/x-tex">\mu=0</script>
you’d get <script type="text/x-tex">P_0</script>,
for <script type="text/x-tex">\mu=1</script>
you’d get <script type="text/x-tex">P_2</script> and
for <script type="text/x-tex">\mu=\frac12</script>
you’d get <script type="text/x-tex">P_1</script>.
Furthermore the curve should be smooth.
The original question has some other constraints,
which I'll ignore here.
The following widget will let you experiment with the solution
I proposed in [my answer][3].
Drag the red points to change the curve and its parametrization,
and drag the white point to change the parametrer value.

[1]: http://math.stackexchange.com/q/2068163/35416 "Math SE question"
[2]: http://math.stackexchange.com/users/401128/ben-andersen "Math SE user"
[3]: http://math.stackexchange.com/a/2068497/35416 "my Math SE answer"

<div id="CSCanvas"></div>
<script id="csinit" type="text/x-cindyscript">
Q(mu):=[
    (x0^2*x1 + y0^2*x1 - 2*x0*x1^2 - 2*x0*y1^2 - 2*x0^2*x2 - 2*y0^2*x2 + 6*x0*x1*x2 - 2*x1^2*x2 + 4*y0*y1*x2 - 2*y1^2*x2 - 2*x0*x2^2 + x1*x2^2 - 2*y0*x1*y2 + 4*x0*y1*y2 - 2*x0*y2^2 + x1*y2^2)*mu^2 + (-x0^2*x1 - y0^2*x1 + 3*x0*x1^2 + 3*x0*y1^2 + x0^2*x2 + y0^2*x2 - 6*x0*x1*x2 + x1^2*x2 - 2*y0*y1*x2 + y1^2*x2 + 3*x0*x2^2 - x1*x2^2 + 2*y0*x1*y2 - 6*x0*y1*y2 + 3*x0*y2^2 - x1*y2^2)*mu - x0*x1^2 - x0*y1^2 + 2*x0*x1*x2 - x0*x2^2 + 2*x0*y1*y2 - x0*y2^2,
    (-2*y0*x1^2 + x0^2*y1 + y0^2*y1 - 2*y0*y1^2 + 4*y0*x1*x2 - 2*x0*y1*x2 - 2*y0*x2^2 + y1*x2^2 - 2*x0^2*y2 - 2*y0^2*y2 + 4*x0*x1*y2 - 2*x1^2*y2 + 6*y0*y1*y2 - 2*y1^2*y2 - 2*y0*y2^2 + y1*y2^2)*mu^2 + (3*y0*x1^2 - x0^2*y1 - y0^2*y1 + 3*y0*y1^2 - 6*y0*x1*x2 + 2*x0*y1*x2 + 3*y0*x2^2 - y1*x2^2 + x0^2*y2 + y0^2*y2 - 2*x0*x1*y2 + x1^2*y2 - 6*y0*y1*y2 + y1^2*y2 + 3*y0*y2^2 - y1*y2^2)*mu - y0*x1^2 - y0*y1^2 + 2*y0*x1*x2 - y0*x2^2 + 2*y0*y1*y2 - y0*y2^2,
    (-x0^2 - y0^2 + 4*x0*x1 - 4*x1^2 + 4*y0*y1 - 4*y1^2 - 2*x0*x2 + 4*x1*x2 - x2^2 - 2*y0*y2 + 4*y1*y2 - y2^2)*mu^2 + (-2*x0*x1 + 4*x1^2 - 2*y0*y1 + 4*y1^2 + 2*x0*x2 - 6*x1*x2 + 2*x2^2 + 2*y0*y2 - 6*y1*y2 + 2*y2^2)*mu - x1^2 - y1^2 + 2*x1*x2 - x2^2 + 2*y1*y2 - y2^2
];
</script>
<script id="csdraw" type="text/x-cindyscript">
mu = (C.x-A.x)/(B.x-A.x);
C.printlabel="$\mu="+mu+"$";
x0 = P0.x; y0 = P0.y;
x1 = P1.x; y1 = P1.y;
x2 = P2.x; y2 = P2.y;
Qinf = [
    x0^2*x1 + y0^2*x1 - 2*x0*x1^2 - 2*x0*y1^2 - 2*x0^2*x2 - 2*y0^2*x2 + 6*x0*x1*x2 - 2*x1^2*x2 + 4*y0*y1*x2 - 2*y1^2*x2 - 2*x0*x2^2 + x1*x2^2 - 2*y0*x1*y2 + 4*x0*y1*y2 - 2*x0*y2^2 + x1*y2^2,
    -2*y0*x1^2 + x0^2*y1 + y0^2*y1 - 2*y0*y1^2 + 4*y0*x1*x2 - 2*x0*y1*x2 - 2*y0*x2^2 + y1*x2^2 - 2*x0^2*y2 - 2*y0^2*y2 + 4*x0*x1*y2 - 2*x1^2*y2 + 6*y0*y1*y2 - 2*y1^2*y2 - 2*y0*y2^2 + y1*y2^2,
    -x0^2 - y0^2 + 4*x0*x1 - 4*x1^2 + 4*y0*y1 - 4*y1^2 - 2*x0*x2 + 4*x1*x2 - x2^2 - 2*y0*y2 + 4*y1*y2 - y2^2
];
layer(1);
drawall(apply(0..10,Q(#/10)), color->[1,0,1]);
drawall(apply(0..10,A.xy+(#/10)*(B.xy-A.xy)), color->[1,0,1]);
Qmu = Q(mu);
layer(3);
draw(Qmu, color->[1,1,0], size->5);
drawtext(Qmu, "$Q_\mu$", offset->[5,5]);
if (Qinf*Qinf > 10^(-14),
  draw(Qinf, color->[0,1,1], size->5);
  drawtext(Qinf, "$Q_\infty", offset->[5,5]);
);
</script>
<script type="text/javascript">
var cdy = CindyJS({
  scripts: "cs*",
  defaultAppearance: {
    dimDependent: 0.7,
    fontFamily: "sans-serif",
    lineSize: 1,
    pointSize: 5.0,
    textsize: 12.0
  },
  angleUnit: "°",
  geometry: [
    {name: "P0", type: "Free", pos: [4.0, -3.0, -1.0], color: [1.0, 0.0, 0.0], labeled: true, printname: "$P_0$"},
    {name: "P1", type: "Free", pos: [4.0, 2.0, 2.0], color: [1.0, 0.0, 0.0], labeled: true, printname: "$P_1$"},
    {name: "P2", type: "Free", pos: [4.0, -0.5, 0.5], color: [1.0, 0.0, 0.0], labeled: true, printname: "$P_2$"},
    {name: "C0", type: "ArcBy3", color: [0.0, 0.0, 1.0], args: ["P0", "P1", "P2"], printname: "$C_{0}$"},
    {name: "A", type: "Free", pos: [0.0, -4.0, -0.5], color: [1.0, 0.0, 0.0], visible: false, labeled: true},
    {name: "B", type: "Free", pos: [4.0, 3.2, 0.4], color: [1.0, 0.0, 0.0], visible: false, labeled: true},
    {name: "a", type: "Join", color: [0.0, 0.0, 0.0], args: ["A", "B"], clip: "inci"},
    {name: "C", type: "PointOnLine", pos: [-3.25, -4.0, -0.5], color: [1.0, 1.0, 1.0], args: ["a"], labeled: true, printname: "$\\mu=0.65$"},
    {name: "b", type: "Segment", color: [0.0, 0.0, 0.0], args: ["A", "B"], size: 3}
  ],
  ports: [{
    id: "CSCanvas",
    width: 680,
    height: 335,
    transform: [{visibleRect: [-9.06, 9.34, 18.14, -4.06]}],
    grid: 1.0,
    snap: true,
    nobackground: "rgb(168,176,192)"
  }],
  csconsole: false,
  use: ["katex"],
  cinderella: {build: 1897, version: [2, 9, 1897]}
});
</script>

If <script type="text/x-tex">P_0,P_1,P_2</script> lie on a single line,
with <script type="text/x-tex">P_1</script> as the center between
<script type="text/x-tex">P_0</script> and
<script type="text/x-tex">P_2</script>,
then it is easy to think of this as a simple constant-speed
parametrization of a line.
But if <script type="text/x-tex">P_1</script> is not the center,
things become more complicated.
Even more so if the points are no longer collinear.

One way to parametrize a line based on three points which are *not*
evenly spaced is to consider these three points as defining a projective scale.
That means that some value
<script type="text/x-tex">\mu\in\mathbb R</script>
results in the point at infinity for this line, while
some other point <script type="text/x-tex">Q_\infty</script> on the line
would correspond to <script type="text/x-tex">\mu=\infty</script>.
Only in case of equidistant defining points would these infinities coincide.

In order to generalize this to the case of non-collinear defining points,
one needs to find a curve for which the concept of a projective scale
makes sense and which can be fully defined by three points.
Projective scales do make sense for points on a conic section,
but a generic conic section is defined by five points.
A special (and in some setups natural) kind of conic section
that can be defined by three points would be a circular arc.

So that is what the above widget demonstrates:
three points define a cirular arc,
and the parameter <script type="text/x-tex">\mu</script>
which can be controlled with the slider at the top
will choose a point on that arc, consistent with the stated constraints.
It is possible to move the parameter outside the 
range <script type="text/x-tex">[0,1]</script> to get an idea of
the larger picture of this parametrization.
To get a better feeling of how the points are distributed,
the widget does draw a bunch of points in magenta which correspond to
evenly distributed parameter values.

Experimenting with this widget it can be seen that for three collinear
and equidistant points, the magenta points are evenly distributed.
Moving the center closer to one of the endpoints makes the distances
contract around that endpoint and expand around the other.
Moving <script type="text/x-tex">P_1</script> away from the segment spanned by
<script type="text/x-tex">P_0</script> and
<script type="text/x-tex">P_2</script> will result in a circular arc.
Even if <script type="text/x-tex">P_1</script> is in the middle of that arc,
distances around that point will be larger than those around the endpoints.
That is because the points aggregate towards
<script type="text/x-tex">Q_\infty</script> which is a point on the circle.

There are other ways to choose a curve through three given points,
and other ways to parametrize a curve in a way consistent with the requirements.
For example, one could build a constant-speed parametrization
of the line segment resp. circular arc,
so that equal changes in parametrer values would result in equal
arc length distances along the curve.
Such a parametrization would have to change speed at
<script type="text/x-tex">P_1</script>, though.
Other ways of parametrizing arcs are conceivable,
but most of them would break down in e.g. a scenario where
<script type="text/x-tex">P_0,P_2,P_1</script>
are collinear *in this order*.
In that case, the circular arc becomes a line “segment”
which passes through infinity.
Dealing with infinities in a consistent way is one of the strengths
of projective geometry, while most metric concepts like distances or angles
become meaningless in such a special case.
