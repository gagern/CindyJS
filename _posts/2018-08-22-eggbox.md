---
layout: post
title:  Boxing an egg
date:   2018-08-22 22:50 +0200
categories: se math
cjs:
  version: v0.8
katex: true
---

In [a question on Mathematics Stack Exchange][1], [CoryG][2] asked for a way to
compute a bounding box for a possibly rotated egg shape.

Here is an illustration of my answer.
It is based on rotating the direction of the box, not the egg.

Move the point for <script type="text/x-tex">b/a</script> to
change that direction.
Move the point for <script type="text/x-tex">c</script> to
adjust the shape of the egg.

[1]: https://math.stackexchange.com/q/2890024/35416
[2]: https://math.stackexchange.com/users/283048/coryg

<div id="CSCanvas1"></div>
<script id="cs1draw" type="text/x-cindyscript">
c = B.x;
B.printlabel = "c=" + c;
f(t):=[((c-2)*cos(t)+c+2)*(cos(t)+1)/4,sin(t)];
n=1000;
connect(apply(0..n, f(#*2*pi/n)), color->[0,0.7,0]);
C.printlabel = "b/a=tan(" + arctan2(C.xy) + ")";
a = C.x;
b = C.y;
rs = roots([-b, 2*a*(c-1), 0, 2*a, b]);
rs = apply(sort(rs, abs(im(#)))_[1,2], 2*arctan(#));
draw(line([a, b, -([a,b]*f(rs_1))]), color->[1,0,0]);
draw(line([a, b, -([a,b]*f(rs_2))]), color->[1,0,0]);
draw(f(rs_1));
draw(f(rs_2));
;
</script>
<script type="text/javascript">
var cdy = CindyJS({
  scripts: "cs1*",
  defaultAppearance: {
    dimDependent: 0.7,
    fontFamily: "sans-serif",
    lineSize: 1,
    pointSize: 5.0,
    textsize: 12.0
  },
  angleUnit: "°",
  geometry: [
    {name: "A", type: "Free", pos: [0.0, -0.0, 4.0], color: [1.0, 0.0, 0.0], visible: false, pinned: true, labeled: true},
    {name: "a", type: "Through", pos: [0.0, -4.0, 0.0], color: [0.0, 0.0, 1.0], args: ["A"], pinned: true, clip: "inci"},
    {name: "B", type: "PointOnLine", pos: [4.0, -0.0, 1.3333333333333333], color: [1.0, 0.0, 0.0], args: ["a"], labeled: true, printname: "c=3"},
    {name: "C0", type: "CircleByRadius", pos: {xx: -0.4444444444444444, yy: -0.4444444444444444, zz: 1.0, xy: 0.0, xz: 0.0, yz: 0.0}, color: [0.0, 0.0, 1.0], radius: 1.5, args: ["A"], pinned: true, printname: "$C_{0}$"},
    {name: "C", type: "PointOnCircle", pos: [{r: -2.3094010767585047, i: -3.7989068362364294E-16}, -4.0, {r: -3.0792014356780046, i: -1.2663022787454774E-16}], color: [1.0, 0.0, 0.0], args: ["C0"], labeled: true, printname: "b/a=tan(1.0472)"},
    {name: "b", type: "Join", color: [1.0, 0.498, 0.0], args: ["A", "C"]}
  ],
  ports: [{
    id: "CSCanvas1",
    width: 680,
    height: 311,
    transform: [{visibleRect: [-2.7057461654370063, 2.1803917551915157, 6.538516188049436, -2.047498821182431]}],
    axes: true,
    grid: 1.0,
    background: "rgb(255,255,255)"
  }],
  csconsole: false,
  cinderella: {build: 1901, version: [2, 9, 1901]}
});
</script>

The egg has the following formula:

<script type="text/x-tex;mode=display">
  x = \frac{r((c-2) \cos \theta + c + 2)(\cos \theta + 1)}{4} \qquad
  y = r \cdot \sin \theta
</script>

The tangents are chosen to be orthogonal to
<script type="text/x-tex">(a,b)</script>
which can be controlled using the point on the circle.
The actual length of that vector <script type="text/x-tex">(a,b)</script>
is irrelevant, only the direction counts.

The points of tangency are determined by solving

<script type="text/x-tex;mode=display">
  bt^4+2at^3+2a(c-1)t-b=0
</script>

for <script type="text/x-tex">t</script>.
Of the four solutions, the two real-valued ones are picked.
Then <script type="text/x-tex">\theta=2\arctan t</script> is the parameter
for the corresponding points of tangency, marked in green.

The dimensions of the box in one dimension can be obtained from those
points of tangency, by applying the rotations that are applied to the
egg to these points, too.
The orthogonal bounds could be computed using
<script type="text/x-tex">(-b,a)</script>
as the direction vector, which is orthogonal to
<script type="text/x-tex">(a,b)</script>.

<div id="CSCanvas2"></div>
<script id="cs2draw" type="text/x-cindyscript">
c = B.x;
B.printlabel = "c=" + c;
f(t):=[((c-2)*cos(t)+c+2)*(cos(t)+1)/4,sin(t)];
n=1000;
connect(apply(0..n, f(#*2*pi/n)), color->[0,0.7,0]);
C.printlabel = "b/a=tan(" + arctan2(C.xy) + ")";
g(a,b):=(
  rs = roots([-b, 2*a*(c-1), 0, 2*a, b]);
  rs = apply(sort(rs, abs(im(#)))_[1,2], 2*arctan(#));
  [
    line([a, b, -([a,b]*f(rs_1))]),
    line([a, b, -([a,b]*f(rs_2))]),
    f(rs_1), f(rs_2)
  ]
);
s1 = g(C.x, C.y);
s2 = g(-C.y, C.x);
edges = [s1_1, s2_1, s1_2, s2_2];
contacts = [s1_3, s2_3, s1_4, s2_4];
corners = apply(cycle(edges), meet(#_1, #_2));
drawall(cycle(corners), color->[1,0,0]);
drawall(corners, color->[1,1,0]);
drawall(contacts);
</script>
<script type="text/javascript">
var cdy = CindyJS({
  scripts: "cs2*",
  defaultAppearance: {
    dimDependent: 0.7,
    fontFamily: "sans-serif",
    lineSize: 1,
    pointSize: 5.0,
    textsize: 12.0
  },
  angleUnit: "°",
  geometry: [
    {name: "A", type: "Free", pos: [0.0, -0.0, 4.0], color: [1.0, 0.0, 0.0], visible: false, pinned: true, labeled: true},
    {name: "a", type: "Through", pos: [0.0, -4.0, 0.0], color: [0.0, 0.0, 1.0], args: ["A"], pinned: true, clip: "inci"},
    {name: "B", type: "PointOnLine", pos: [4.0, -0.0, 1.3333333333333333], color: [1.0, 0.0, 0.0], args: ["a"], labeled: true, printname: "c=3"},
    {name: "C0", type: "CircleByRadius", pos: {xx: -0.4444444444444444, yy: -0.4444444444444444, zz: 1.0, xy: 0.0, xz: 0.0, yz: 0.0}, color: [0.0, 0.0, 1.0], radius: 1.5, args: ["A"], pinned: true, printname: "$C_{0}$"},
    {name: "C", type: "PointOnCircle", pos: [{r: -2.3094010767585047, i: -3.7989068362364294E-16}, -4.0, {r: -3.0792014356780046, i: -1.2663022787454774E-16}], color: [1.0, 0.0, 0.0], args: ["C0"], labeled: true, printname: "b/a=tan(1.0472)"},
    {name: "b", type: "Join", color: [1.0, 0.498, 0.0], args: ["A", "C"]}
  ],
  ports: [{
    id: "CSCanvas2",
    width: 680,
    height: 311,
    transform: [{visibleRect: [-2.7057461654370063, 2.1803917551915157, 6.538516188049436, -2.047498821182431]}],
    axes: true,
    grid: 1.0,
    background: "rgb(255,255,255)"
  }],
  csconsole: false,
  cinderella: {build: 1901, version: [2, 9, 1901]}
});
</script>
